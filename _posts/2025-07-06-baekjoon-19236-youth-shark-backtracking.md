---
layout: post
title: "백준 19236번 청소년 상어 - 자료구조 설계와 백트래킹 최적화"
date: 2025-07-06
categories: [Algorithm, 백준]
tags: [백트래킹, DFS, Python, 상태복원, 자료구조]
---

# 백준 19236번 청소년 상어 - 자료구조 설계와 백트래킹 최적화

## 들어가며
DFS 백트래킹 문제를 풀면서 겪었던 여러 실수들과 정답 코드 분석을 통한 깨달음을 공유합니다. 특히 자료구조 설계의 중요성과 효율적인 백트래킹 방법을 중심으로 정리했습니다.

## 문제 분석
- 4×4 격자에서 물고기들이 각자의 방향으로 이동
- 상어가 물고기를 잡으며 최대 점수 획득
- **핵심**: 상어 이동 → 물고기들 순서대로 이동 → 상어 이동... 반복

## 초기 접근에서의 실수들

### 1. Python 기본 문법 혼동
**튜플 관련 실수들:**
```python
# 잘못된 접근
(1,2,3) + (3)     # TypeError 발생
t[3] = 1          # 튜플은 불변!

# 올바른 접근  
(1,2,3) + (3,)    # (1, 2, 3, 3)
t = t + (new,)    # 새로운 튜플 생성
```

**핵심 개념:**
- `(3)`은 정수, `(3,)`은 튜플
- 튜플 연산은 항상 새로운 객체 생성
- 요소 추가가 빈번하면 리스트 사용 고려

### 2. 전역변수 vs 지역변수 문제
```python
def dfs():
    # 문제가 된 코드
    fish = t_fish  # 이 순간 fish가 지역변수가 됨!
    
# 해결 방법
def dfs():
    global fish  # 명시적 선언 필요
```

### 3. **Python 스왑 메커니즘과 주의사항**

**기본 스왑 동작 원리:**
```python
arr[r][c], arr[nr][nc] = arr[nr][nc], arr[r][c]

# 실행 단계:
# 1단계: 우변 평가 (튜플 생성)
temp_tuple = (arr[nr][nc], arr[r][c])
# 2단계: 좌변에 언패킹 할당
arr[r][c] = temp_tuple[0]
arr[nr][nc] = temp_tuple[1]
```

**의존성이 있는 경우:**
```python
# arr[r][c] = 2일 때
arr[r][c], arr[nr][nc] = arr[r][c]+1, arr[r][c]+2
# 결과: arr[r][c] = 3, arr[nr][nc] = 4
# 우변이 먼저 평가되므로 둘 다 원래 값 2를 사용
```

**스왝 시 발생할 수 있는 오류들:**
```python
# 1. 개수 불일치
a, b = 1, 2, 3  # ValueError: too many values to unpack

# 2. 인덱스 오류  
arr[0][0], arr[5][5] = arr[1][1], arr[0][0]  # IndexError

# 3. 리스트 스왑 시 참조 문제
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1, list2 = list2, list1  # 참조만 교환
list1[0] = 999  # 원본 [4,5,6]도 영향받음

# 안전한 리스트 내용 교환
list1[:], list2[:] = list2[:], list1[:]
```

## 가장 큰 문제들

### 1. **자료구조 설계의 실패**

**내 코드 (비효율적):**
```python
fish = [[-1] for _ in range(17)]  # 물고기 정보
board = [[0]*4 for _ in range(4)] # 보드 정보
# 두 배열을 동시에 관리해야 하는 복잡함
```

**정답 코드 (효율적):**
```python
v = [[[0]*2 for _ in range(4)] for _ in range(4)]
# v[i][j] = [물고기번호, 방향] - 통합 관리!
```

**문제점:**
- 물고기 위치 변경 시 `fish`와 `board` 두 곳 모두 수정 필요
- 동기화 문제 발생 가능성
- 복잡한 인덱스 관리

### 2. **백트래킹 상태 복원 미고려**

### 문제 상황 파악
**처음 놓친 핵심**: "상어의 움직임 이후 물고기들이 움직이기 때문에 물고기 좌표는 달라져 있다"

### 구체적인 예시
```
i-th 상태: 물고기 1번(1,1), 2번(2,2), 3번(3,3)
│
├─ 상어가 경로1 선택
│  ├─ 상어 이동 후 move 함수 실행 → 1번(1,2), 2번(2,1), 3번(3,1)
│  ├─ 다음 상어 이동 및 탐색 완료
│  └─ 백트래킹 시점 ⚠️
│
└─ 상어가 경로2 선택하려 할 때
   ├─ 물고기들이 (1,2), (2,1), (3,1)에서 시작? ❌ 틀렸다!
   └─ 물고기들이 (1,1), (2,2), (3,3)에서 시작? ⭕ 맞다!
```

### 3. **비효율적인 백트래킹 방식**

**내 코드 (메모리 낭비):**
```python
# 매번 전체 상태를 저장하고 복원
t_fish = [l[:] for l in fish]
t_board = [l[:] for l in board]
# ... 작업 후
fish = t_fish  # 전체 복원
```

**정답 코드 (효율적):**
```python
# 변경되는 부분만 저장하고 복원
fn,fd=v[ni][nj]           # 먹을 물고기 정보만 저장
v[ni][nj][1]=-1          # 최소 변경
nv=[[x[:] for x in lst] for lst in v]  # 필요한 시점에만 복사
dfs(ni,nj,fd,sm+fn,nv)
v[ni][nj][1]=fd          # 최소 복원
```

## 정답 코드에서 배운 핵심 개념들

### 1. **자료구조 통합의 중요성**
```python
def find(idx, v):
    for i in range(4):
        for j in range(4):
            if v[i][j][0]==idx:  # 물고기 번호 검색
                return i,j,v[i][j][1]
```
- 하나의 자료구조로 모든 정보 관리
- 동기화 문제 해결
- 직관적인 코드

### 2. **Python스러운 간단한 교환**
```python
# 내 복잡한 방식
t_original = [target_fish[0], target_fish[1], nd, cur_fish[3]]
t_target = [cur_fish[0], cur_fish[1], target_fish[2], target_fish[3]]
fish[idx] = t_original
fish[target_num] = t_target

# 정답의 간단한 방식
v[ci][cj][1]=td     # 방향만 먼저 업데이트
v[ci][cj],v[ni][nj]=v[ni][nj],v[ci][cj]  # 스왑!
```

### 3. **최소 백트래킹 원칙**
- 모든 상태를 복원할 필요 없음
- 변경된 부분만 기록하고 복원
- 메모리 효율성 고려

### 4. **상어 표시 방법**
```python
v[ni][nj][1]=-1     # 물고기를 먹었다는 표시
# 별도의 상어 위치 변수 없이 -1로 구분
```

## 핵심 교훈들

### 설계 단계에서의 교훈
1. **자료구조 설계가 코드의 복잡도를 결정한다**
2. **통합 관리 vs 분리 관리의 트레이드오프**
3. **문제에서 요구하는 정보를 하나로 묶을 수 있는지 고민**

### 구현 단계에서의 교훈
1. **백트래킹 ≠ 무조건 전체 복원**
2. **Python의 간결한 문법 적극 활용 (단, 주의사항 숙지)**
3. **메모리 효율성도 고려하자**
4. **상태 변화 후 다른 경로 탐색을 항상 고려**

### 디버깅에서의 교훈
1. **Python LEGB 규칙 숙지**
2. **튜플 vs 리스트 특성 이해**
3. **전역변수 사용 시 명시적 선언**
4. **스왑 시 참조 vs 값 복사 구분**

### Python 스왑 사용 시 주의사항
1. **우변이 먼저 평가됨** - 의존성 문제 없음
2. **개수 불일치 주의** - 가장 흔한 오류
3. **리스트 스왑 시 참조 공유** - 필요시 복사 사용
4. **인덱스 접근 오류** - 범위 체크 필수

## 마무리
이 문제를 통해 **자료구조 설계의 중요성**과 **효율적인 백트래킹 방법**을 배웠습니다. 단순히 동작하는 코드를 넘어서 **최적화된 설계**를 고민하는 습관을 기르는 것이 중요하다는 것을 깨달았습니다.

특히 "상어 움직임 후 물고기 좌표 변화"라는 핵심을 놓쳤던 경험을 통해, **문제의 실행 순서를 정확히 파악**하고 **모든 상태 변화를 고려**하는 것의 중요성을 배웠습니다.

또한 Python의 스왑 메커니즘을 정확히 이해하고, **언제 참조를 교환하고 언제 값을 복사해야 하는지** 구분하는 것도 중요한 교훈이었습니다.
