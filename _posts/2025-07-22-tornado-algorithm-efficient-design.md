---
layout: post
title: "토네이도 문제를 통해 배운 효율적인 알고리즘 설계 - 배열 회전 vs 직접 구현"
date: 2025-07-22
categories: [Algorithm, 백준]
tags: [시뮬레이션, 최적화, 배열회전, 좌표변환, 성능분석]
---

## 들어가며

토네이도 문제를 풀면서 두 가지 완전히 다른 접근 방식을 경험했다. 하나는 **배열 회전을 활용한 깔끔해 보이는 해법**이고, 다른 하나는 **직접 구현한 효율적인 해법**이다.

겉으로 보기에는 첫 번째 방법이 더 우아하고 간단해 보였지만, 실제로는 성능상 치명적인 문제가 있었다. 이 경험을 통해 **"깔끔해 보이는 코드"와 "효율적인 코드"의 차이**를 뼈저리게 느꼈다.

## 내가 처음에 가진 안좋은 코드 습관들

### 1. 알고 있는 기법에 현혹되기

처음에는 "배열 회전"이라는 기법을 알고 있었기 때문에 이를 활용하고 싶었다. **"모든 방향을 좌측으로 통일하면 깔끔하겠다"**는 생각에 사로잡혔다.

```python
# 내가 처음 시도한 방식의 핵심 아이디어
def solve():
    for direction in range(4):
        # 좌측으로만 처리
        move_left()
        # 배열을 90도 회전시켜서 다음 방향 준비
        arr = rotate_right_90(arr)
```

**문제점**: 알고 있는 도구를 문제에 맞추려 했지, 문제에 적합한 도구를 선택하지 않았다.

### 2. 시간 복잡도 계산 소홀히 하기

배열 회전이 O(N²) 시간이 소요된다는 점을 간과했다. **"함수로 나누어져 있으니 O(1)일 것"**이라고 착각했다.

```python
# 잘못된 복잡도 계산
# move() 함수가 O(1)이니까 전체가 O(N²)일 거야...
for cnt in CNT:  # O(N)
    for i in range(cnt):  # O(N)
        move(r, c)  # O(1)이라고 착각
    arr = rotate_right_90(arr)  # O(N²) - 이걸 놓쳤다!
```

**실제 복잡도**: O(N³) - 매번 배열 회전에 O(N²)가 소요됨

### 3. 메모리 사용량 무시하기

배열 회전 시마다 새로운 N×N 배열을 생성한다는 점을 고려하지 않았다. 메모리 효율성에 대한 고민이 전혀 없었다.

### 4. "깔끔함"에 대한 착각

함수로 나누어져 있고 코드가 짧다고 해서 좋은 코드라고 생각했다. **외형적 깔끔함**과 **본질적 효율성**을 구분하지 못했다.

## 정답 코드와 비교했을 때 부족했던 부분들

### 1. 문제 본질 파악 능력 부족

**정답 코드의 핵심**: 토네이도 이동 패턴은 1→1→2→2→3→3... 형태의 규칙적인 달팽이 패턴

```python
# 정답 코드에서 패턴 구현
cnt_mx = 1
while (ci, cj) != (0, 0):
    ci, cj = ci + di[dr], cj + dj[dr]  # 한 칸 이동
    
    cnt += 1
    if cnt == cnt_mx:
        cnt = 0
        dr = (dr + 1) % 4  # 방향 전환
        if flag == 0:
            flag = 1
        else:
            flag = 0
            cnt_mx += 1  # 이동 거리 증가
```

**내가 놓친 부분**: 이 패턴을 직접 구현하는 것이 가장 효율적이라는 인사이트

### 2. 사전 계산의 가치 인식 부족

**정답 코드의 혁신**: 4방향 × 10위치 좌표를 미리 계산

```python
# 각 방향별 모래 분산 좌표를 사전 계산
ai = [[-2,-1,-1,-1, 0, 1, 1, 1, 2, 0],  # 좌
      [ 0, 1, 0,-1, 2, 1, 0,-1, 0, 1],  # 하
      [ 2, 1, 1, 1, 0,-1,-1,-1,-2, 0],  # 우
      [ 0,-1, 0, 1,-2,-1, 0, 1, 0,-1]]  # 상
```

**내가 놓친 부분**: 반복되는 계산을 미리 테이블로 만드는 최적화 기법

### 3. In-place 처리의 중요성 무시

**정답 코드**: 원본 배열을 직접 수정하여 메모리 효율성 극대화

**내 코드**: 매번 새로운 배열 생성으로 메모리 낭비

### 4. 좌표 변환 vs 배열 회전의 효율성 차이

**정답 코드**: 좌표 계산만으로 모든 방향 처리
- 시간: O(1)
- 공간: O(1)

**내 코드**: 물리적 배열 회전
- 시간: O(N²)
- 공간: O(N²)

## 앞으로 고려해야 할 점들

### 1. 성능 우선 사고 습관

코드를 작성하기 전에 반드시 시간/공간 복잡도를 먼저 계산하자.

```python
# 앞으로의 사고 과정
1. 문제 요구사항 파악
2. 시간/공간 복잡도 계산
3. 여러 접근법 비교
4. 가장 효율적인 방법 선택
5. 구현
```

### 2. 문제 본질에 집중하기

**"내가 아는 기법을 어떻게 써볼까?"** ❌
**"이 문제의 본질은 무엇이고, 가장 직접적인 해법은 무엇인가?"** ✅

### 3. 과도한 추상화 피하기

모든 방향을 하나로 통일하려는 시도가 오히려 비효율을 만들었다. **적절한 수준의 직접성**이 때로는 더 효율적이다.

### 4. 메모리 효율성 고려

특히 대용량 데이터를 다루는 문제에서는 메모리 사용 패턴을 반드시 고려해야 한다.

### 5. 벤치마킹 습관

여러 접근법을 실제로 구현해보고 성능을 비교하는 습관을 기르자.

## 핵심 교훈

### 가장 중요한 깨달음

```
겉보기 깔끔함 ≠ 실제 효율성
코드의 길이 ≠ 성능의 우수성
```

### 효율적인 알고리즘 설계 원칙

1. **문제 패턴 직접 구현 > 범용 기법 억지 적용**
2. **사전 계산 > 반복 계산**
3. **In-place 처리 > 새로운 메모리 할당**
4. **좌표 변환 > 물리적 배열 조작**

### 성능 분석의 중요성

```python
# 첫 번째 코드 (비효율적)
시간 복잡도: O(N³)
공간 복잡도: O(N²)
메모리 패턴: 반복적 할당/해제

# 두 번째 코드 (효율적)  
시간 복잡도: O(N²)
공간 복잡도: O(1)
메모리 패턴: In-place 처리
```

**결과**: N=99일 때 약 100배의 성능 차이 발생

## 마무리

이 문제를 통해 **"알고리즘 최적화는 코딩 스킬보다 사고방식의 문제"**라는 것을 깨달았다. 

특히 **문제의 본질을 파악하고 가장 직접적인 해법을 찾는 능력**이 복잡한 기법을 아는 것보다 훨씬 중요하다는 점을 배웠다.

앞으로는 겉으로 보기에 깔끔한 해법에 현혹되지 않고, **성능과 효율성을 먼저 고려하는 개발자**가 되어야겠다.

**효율적인 알고리즘 설계는 화려한 기법이 아닌, 문제 본질에 대한 깊은 이해에서 시작된다.**
