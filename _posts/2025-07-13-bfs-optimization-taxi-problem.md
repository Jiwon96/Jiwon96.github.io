---
layout: post
title: "BFS 최적화로 실행시간 단축하기 - 백준 택시 문제 개선 사례"
date: 2025-07-13
categories: [Algorithm, 백준]
tags: [BFS, 최적화, 알고리즘]
---

## 1. 문제 상황과 초기 접근법

백준의 택시 문제를 해결하면서 BFS 구현에 대해 많은 것을 배울 수 있었습니다. 처음에는 기본적인 BFS 패턴을 사용했지만, 실행시간이 예상보다 오래 걸리는 문제가 있었습니다. 이번 포스트에서는 어떤 부분을 개선했는지, 그리고 그 결과 어떤 성능 향상을 얻을 수 있었는지 공유해보겠습니다.

## 2. 초기 코드의 문제점 분석

### 2.1 BFS 내부에서의 불필요한 반복 작업

처음 작성한 코드에서 가장 큰 문제점은 BFS 탐색 중에 매번 모든 승객의 위치를 확인하는 것이었습니다:

```python
# 문제가 있던 초기 코드
while q:
    r, c, d = q.popleft()
    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nr, nc, nd = r + dr, c + dc, d + 1
        if 0 <= nr < N and 0 <= nc < N and (not arr[nr][nc]):
            # 여기서 매번 모든 승객을 순회! 
            for j in range(M):  # O(M) 시간 추가 소요
                if (r, c) == s[j]:
                    # 거리 업데이트 로직
                if (nr, nc) == s[j]:
                    # 거리 업데이트 로직
```

이 방식의 문제점:
- **시간복잡도 증가**: BFS의 각 스텝마다 O(M) 시간이 추가로 소요
- **중복 체크**: 이미 찾은 목표점도 계속 확인
- **코드 복잡성**: 조건문이 중첩되어 가독성 저하

### 2.2 방문 체크 순서 문제

또 다른 문제는 방문 체크 순서였습니다:

```python
# 잘못된 패턴
for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
    nr, nc, nd = r + dr, c + dc, d + 1
    if 0 <= nr < N and 0 <= nc < N and (not arr[nr][nc]):
        # 먼저 로직 수행
        for j in range(M):
            # ... 거리 계산
        
        if v[nr][nc] != -1: continue  # 나중에 방문 체크
        v[nr][nc] = nd
        q.append((nr, nc, nd))
```

이미 방문한 노드에 대해서도 불필요한 계산을 수행하고, 심지어 중복으로 큐에 추가될 수 있는 위험이 있었습니다.

### 2.3 조기 종료 최적화 부재

모든 목표점까지의 거리를 찾았음에도 불구하고 BFS가 계속 진행되어 불필요한 탐색을 수행했습니다.

## 3. 개선된 코드의 핵심 아이디어

### 3.1 딕셔너리 활용한 목표점 매핑

가장 큰 개선점은 목표점들을 딕셔너리로 미리 매핑해두는 것이었습니다:

```python
def bfs(start_r, start_c, targets):
    # 목표점들을 딕셔너리로 매핑 - O(1) 검색 가능
    target_dict = {pos: idx for idx, pos in enumerate(targets)}
    result = [987654321] * len(targets)
    found = 0
    
    while q and found < len(targets):  # 조기 종료 조건
        r, c, d = q.popleft()
        
        # O(1) 시간에 목표점 확인
        if (r, c) in target_dict:
            idx = target_dict[(r, c)]
            if result[idx] == 987654321:  # 아직 찾지 못한 목표점
                result[idx] = d
                found += 1
```

### 3.2 found 카운터를 통한 조기 종료

`found` 변수로 찾은 목표점의 개수를 추적하여, 모든 목표점을 찾으면 즉시 BFS를 종료합니다:

```python
while q and found < len(targets):  # 모든 목표점을 찾으면 종료
    # BFS 로직
    if (r, c) in target_dict:
        # ... 
        found += 1  # 목표점 발견 시 카운터 증가
```

### 3.3 올바른 BFS 구현 패턴

방문 체크를 큐에 추가하기 전에 수행하여 중복 탐색을 방지했습니다:

```python
for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
    nr, nc = r + dr, c + dc
    # 먼저 모든 조건을 체크
    if 0 <= nr < N and 0 <= nc < N and v[nr][nc] == -1 and not arr[nr][nc]:
        v[nr][nc] = d + 1  # 즉시 방문 표시
        q.append((nr, nc, d + 1))  # 그 후 큐에 추가
```

## 4. 성능 개선 결과

### 시간복잡도 비교

**기존 코드:**
- BFS: O(N²)
- 매 스텝마다 승객 순회: O(M)
- **전체: O(N² × M)**

**개선된 코드:**
- BFS: O(N²)
- 목표점 확인: O(1)
- 조기 종료로 실제 탐색 범위 감소
- **전체: O(N²)** (실질적으로 더 빠름)

### 메모리 사용량 개선

- 중복 큐 추가 방지로 메모리 사용량 감소
- 불필요한 반복 계산 제거

## 5. 배운 점과 앞으로 고려할 사항

### 핵심 배운 점

1. **자료구조 선택의 중요성**: 리스트 순회 대신 딕셔너리 활용으로 O(M) → O(1) 개선
2. **조기 종료 최적화**: 불필요한 탐색 제거의 효과
3. **올바른 BFS 패턴**: 방문 체크 순서의 중요성

### 앞으로 고려할 사항

- **메모리 vs 시간 트레이드오프**: 딕셔너리 사용으로 약간의 메모리를 더 사용하지만 시간을 크게 단축
- **코드 가독성**: 최적화와 가독성 사이의 균형점 찾기
- **재사용성**: 함수의 책임을 명확히 분리하여 재사용 가능한 코드 작성

이번 경험을 통해 알고리즘 최적화에서는 단순히 동작하는 코드를 작성하는 것을 넘어서, 효율적인 자료구조 선택과 불필요한 연산 제거가 얼마나 중요한지 깨달을 수 있었습니다. 특히 BFS와 같은 기본 알고리즘도 구현 방식에 따라 성능 차이가 크게 날 수 있다는 점이 인상 깊었습니다.
