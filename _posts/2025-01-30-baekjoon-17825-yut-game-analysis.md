---
layout: post
title: "백준 17825 주사위 윷놀이 - 노드 유일성 원칙과 그래프 설계의 중요성"
date: 2025-01-30
categories: [Algorithm, 백준]
tags: [백트래킹, 그래프, 설계, 추상화, 인접리스트]
---

## 들어가며

백준 17825번 주사위 윷놀이 문제를 풀면서 겪은 뼈아픈 실패 경험을 통해 **그래프 설계의 중요성**과 **노드 유일성 원칙**에 대해 깊이 있게 분석해보고자 한다.

단순해 보이는 백트래킹 문제였지만, 실제로는 **"어떻게 그래프를 설계하느냐"**가 모든 것을 결정하는 문제였다.

## 내가 처음 작성한 코드의 문제점

### 기본 접근 방식
처음에는 4개의 트랙을 분리해서 관리하는 방식으로 접근했다:

```python
track[0] = [빨간 트랙]  # [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,-1]
track[1] = [파란 트랙1] # [10,13,16,19,25,30,35,40,-1]
track[2] = [파란 트랙2] # [20,22,24,25,30,35,40,-1] 
track[3] = [파란 트랙3] # [30,28,27,26,25,30,35,40,-1]
```

각 말의 위치를 `(트랙번호, 위치)` 형태로 관리했다.

### 치명적인 중복 체크 버그

가장 큰 문제는 빨간 트랙과 파란 트랙 간의 중복 체크 로직이었다:

```python
else: # 하나는 빨간, 하나는 파란
    if (t[other_player][1], t[other_player][0]) == (cur_track, cur_pos):
        is_duplicate = True
```

**문제**: 빨간 트랙(0)과 파란 트랙(1,2,3)은 트랙 번호가 다르므로 이 조건은 **절대 True가 될 수 없다**!

결과적으로 빨간-파란 트랙 간의 중복이 전혀 체크되지 않았다.

## 핵심 패인: 유일성 부재가 만든 복잡성의 악순환

### 진짜 문제의 뿌리
```
유일성 부재 → 복잡한 예외 처리 → 버그 연쇄 발생 → 디버깅 지옥
```

### 내가 겪은 설계 실패의 전형적 패턴
1. **초기 설계**: (트랙, 위치) 방식으로 "간단하게" 시작
2. **문제 발견**: 중복 체크가 복잡함을 깨달음
3. **임시방편**: 케이스별로 예외 처리 추가
   ```python
   if 둘다파란: ...
   elif 둘다빨간: ...  
   else: # 하나는 빨간, 하나는 파란
       if 40점: ...
       elif 30점: ...
       else: ... # 여기서 버그!
   ```
4. **악순환**: 예외 처리가 계속 늘어나고 버그도 계속 발생
5. **포기**: 복잡한 로직에 매몰되어 근본 원인을 못 찾음

### 유일성 설계의 결정적 중요성
**"처음 설계가 모든 것을 결정한다"**

- ✅ **올바른 설계**: 유일성 보장 → 단순한 로직 → 버그 없음
- ❌ **잘못된 설계**: 유일성 부재 → 복잡한 예외처리 → 버그 연쇄

## 점수 기반 중복 체크의 한계

내가 버그를 "수정"한다고 시도한 방법:

```python
# 점수가 같으면 중복으로 간주
if track[t[other_player][1]][t[other_player][0]] == track[cur_track][cur_pos]:
    is_duplicate = True
```

하지만 이 접근도 근본적 한계가 있었다.

### 30점의 이중성 문제
윷놀이 보드에는 **30점이 두 곳**에 존재한다:
- **15번 분기점**: 빨간트랙(0,15) = 파란트랙3(3,0) = 30점
- **합류점**: 모든 파란트랙이 합류한 후의 30점

```python
# 실제 발생하는 문제
말A: 15번 분기점의 30점 (분기점)
말B: 합류점의 30점 (25→30으로 이동)
# 다른 물리적 위치인데 점수가 같아서 중복으로 잘못 판정!
```

### 기타 점수 중복 사례들
```python
빨간트랙 22점(0,11) vs 파란트랙2 22점(2,1)  # 다른 위치, 같은 점수
빨간트랙 24점(0,12) vs 파란트랙2 24점(2,2)  # 다른 위치, 같은 점수
빨간트랙 26점(0,13) vs 파란트랙3 26점(3,3)  # 다른 위치, 같은 점수
```

**결론**: **같은 점수 ≠ 같은 물리적 위치**

## 그래프 표현 방법론: 인접 리스트의 선택

### 주요 그래프 표현 방식들

#### 1. 인접 행렬 (Adjacency Matrix)
```python
# N×N 2차원 배열
adj = [[0, 1, 0, 1],    # 노드 0에서 1,3으로 연결
       [0, 0, 1, 0],    # 노드 1에서 2로 연결  
       [0, 0, 0, 1],    # 노드 2에서 3으로 연결
       [0, 0, 0, 0]]    # 노드 3은 끝점
```
- **장점**: 두 노드 간 연결 확인이 O(1)
- **단점**: 공간 복잡도 O(N²), sparse graph에서 비효율적

#### 2. 인접 리스트 (Adjacency List) ⭐
```python
# 각 노드별로 연결된 노드들의 리스트
adj = [
    [1, 3],    # 노드 0에서 1,3으로 연결
    [2],       # 노드 1에서 2로 연결
    [3],       # 노드 2에서 3으로 연결  
    []         # 노드 3은 끝점
]

# 윷놀이에서 사용한 방식
graph = [
    [1],        # 0번 노드에서 1번으로만 이동
    [2],        # 1번 노드에서 2번으로만 이동
    [6, 21],    # 분기점: 6번 또는 21번으로 이동 가능
    [7],
    ...
]
```
- **장점**: 공간 효율적 O(V+E), 연결된 노드 순회가 빠름
- **단점**: 특정 두 노드 간 연결 확인이 O(degree)

#### 3. 간선 리스트 (Edge List)
```python
# 모든 간선을 (시작점, 끝점) 쌍으로 저장
edges = [(0, 1), (0, 3), (1, 2), (2, 3)]
```
- **장점**: 간단한 표현, Kruskal 알고리즘 등에 유용
- **단점**: 특정 노드의 이웃 찾기가 비효율적

### 윷놀이 문제에 인접 리스트가 적합한 이유

1. **분기점 표현 용이**: `[6, 21]` 같은 방식으로 선택지 명확히 표현
2. **메모리 효율적**: sparse graph이므로 인접행렬보다 효율적  
3. **순회 편리**: 각 노드에서 갈 수 있는 곳들을 쉽게 iterate
4. **직관적**: "여기서 어디로 갈 수 있나?" 질문에 바로 답변

## 체계적 유일성 보장 그래프 설계법

### Step 1: 물리적 보드 구조 정확히 파악

윷놀이 보드의 실제 모습을 먼저 이해해야 한다:

```
시작(0) → 2 → 4 → 6 → 8 → 10 → 12 → 14 → 16 → 18 → 20 → ...
                    ↓     ↓                    ↓
                   13    22                   28
                    ↓     ↓                    ↓  
                   16    24                   27
                    ↓     ↓                    ↓
                   19 →  25 ← ← ← ← ← ← ← ← ← 26
                         ↓
                        30 → 35 → 40 → 도착
```

### Step 2: 구별되는 모든 위치 식별 (핵심!)

**같은 점수지만 다른 물리적 위치들을 찾아야 한다:**

```python
# 22점인 곳들 (서로 다른 물리적 위치!)
바깥 트랙의 22점: 빨간선을 따라 온 22점  
파란2 트랙의 22점: 20점에서 분기해서 온 22점

# 30점인 곳들 (가장 복잡!)
15번 분기점의 30점: 빨간선의 30점 OR 파란3에서 시작점
합류 후의 30점: 25점 다음의 30점
```

### Step 3: 유일성 보장 원칙 적용

**원칙**: 물리적으로 다른 위치 = 다른 노드 ID

```python
# ✅ 올바른 분류
노드 11: 바깥 트랙의 22점 (빨간선)
노드 25: 파란2 트랙의 22점 (20→22)

노드 15: 15번 분기점의 30점 (빨간선 OR 파란3 시작)
노드 30: 합류 후의 30점 (25→30)
```

### Step 4: 체계적 ID 부여 방법

**구역별 ID 할당 전략:**

```python
# 1. 메인 트랙 (빨간선)
0-20: 시작점부터 40점까지

# 2. 파란1 트랙 (10점 분기)  
21-23: 13점, 16점, 19점

# 3. 파란2 트랙 (20점 분기)
24-25: 22점, 24점  

# 4. 파란3 트랙 (30점 분기)
26-28: 28점, 27점, 26점

# 5. 합류 구간
29: 25점 (모든 파란트랙 합류)
30: 30점 (합류 후)  
31: 35점 (합류 후)
32: 40점 (합류 후)

# 6. 도착
33: 도착점
```

### Step 5: 완전한 그래프 구현

```python
# 인접 리스트로 연결 관계 정의
graph = [
    [1],      # 0: 시작 → 2점
    [2],      # 1: 2점 → 4점
    [3],      # 2: 4점 → 6점
    [4],      # 3: 6점 → 8점
    [5],      # 4: 8점 → 10점
    [6, 21],  # 5: 10점 → 12점 OR 13점(파란1)
    [7],      # 6: 12점 → 14점
    [8],      # 7: 14점 → 16점
    [9],      # 8: 16점 → 18점
    [10],     # 9: 18점 → 20점
    [11, 24], # 10: 20점 → 22점 OR 22점(파란2)
    [12],     # 11: 22점(바깥) → 24점(바깥)
    [13],     # 12: 24점(바깥) → 26점
    [14],     # 13: 26점 → 28점
    [15],     # 14: 28점 → 30점(바깥)
    [16, 26], # 15: 30점(분기) → 32점 OR 28점(파란3)
    [17],     # 16: 32점 → 34점
    [18],     # 17: 34점 → 36점
    [19],     # 18: 36점 → 38점
    [20],     # 19: 38점 → 40점(바깥)
    [32],     # 20: 40점(바깥) → 도착
    [22],     # 21: 13점 → 16점  
    [23],     # 22: 16점 → 19점
    [29],     # 23: 19점 → 25점(합류)
    [25],     # 24: 22점(파란2) → 24점(파란2)
    [29],     # 25: 24점(파란2) → 25점(합류)
    [27],     # 26: 28점(파란3) → 27점
    [28],     # 27: 27점 → 26점  
    [29],     # 28: 26점 → 25점(합류)
    [30],     # 29: 25점(합류) → 30점(합류)
    [31],     # 30: 30점(합류) → 35점
    [32],     # 31: 35점 → 40점(합류)
    [33],     # 32: 40점(합류) → 도착
    []        # 33: 도착 (더 이상 이동 없음)
]

# 각 노드의 점수
score = [
    0, 2, 4, 6, 8,        # 0-4: 시작~8점
    10, 12, 14, 16, 18,   # 5-9: 10점~18점  
    20, 22, 24, 26, 28,   # 10-14: 20점~28점
    30, 32, 34, 36, 38,   # 15-19: 30점~38점
    40,                   # 20: 40점(바깥)
    13, 16, 19,          # 21-23: 파란1 (13,16,19점)
    22, 24,              # 24-25: 파란2 (22,24점)  
    28, 27, 26,          # 26-28: 파란3 (28,27,26점)
    25, 30, 35, 40,      # 29-32: 합류 (25,30,35,40점)
    0                    # 33: 도착 (점수 없음)
]
```

### Step 6: 유일성 검증

**체크리스트:**
1. **같은 점수인 노드들이 실제로 다른 물리적 위치인가?**
   ```python
   노드 11 (22점, 바깥) vs 노드 24 (22점, 파란2) → ✅ 다른 위치
   노드 15 (30점, 분기) vs 노드 30 (30점, 합류) → ✅ 다른 위치  
   ```

2. **같은 물리적 위치가 여러 노드로 표현되지 않았나?**
   ```python
   10점 분기점 = 노드 5 (하나로 통합) → ✅
   20점 분기점 = 노드 10 (하나로 통합) → ✅
   ```

## 완벽한 정답 코드

```python
def backtrack(depth, current_score, horses):
    global max_score
    
    if depth == 10:
        max_score = max(max_score, current_score)
        return
    
    for i in range(4):
        current_pos = horses[i]
        
        if current_pos == 32:  # 이미 도착한 말
            continue
        
        # 다음 위치 계산
        if len(graph[current_pos]) == 2:  # 분기점
            next_pos = graph[current_pos][1]  # 파란 경로
        else:
            next_pos = graph[current_pos][0]  # 일반 경로
        
        # 주사위 값만큼 이동
        for _ in range(1, dice[depth]):
            if next_pos != 32:
                next_pos = graph[next_pos][0]
        
        # 중복 체크: 이것이 핵심!
        if next_pos == 32 or (next_pos < 32 and next_pos not in horses):
            original_pos = horses[i]
            horses[i] = next_pos
            
            backtrack(depth + 1, current_score + score[next_pos], horses)
            
            horses[i] = original_pos

dice = list(map(int, input().split()))
max_score = 0
backtrack(0, 0, [0, 0, 0, 0])
print(max_score)
```

### 중복 체크의 혁신적 단순화

```python
# ❌ 내 원래 코드: 복잡한 케이스 분류
if t[other_player][1] > 0 and cur_track > 0:
    # 둘 다 파란트랙...
elif t[other_player][1] == 0 and cur_track == 0:
    # 둘 다 빨간트랙...
else:
    # 하나는 빨간, 하나는 파란... (버그 발생)

# ✅ 정답 코드: 단순한 한 줄
if next_pos not in horses:
    # 이동 가능!
```

## 핵심 교훈

### 가장 중요한 깨달음
```
점수 = 노드의 속성 (Property)
점수 ≠ 노드의 식별자 (Identity)

같은 점수 ≠ 같은 물리적 위치
```

### 설계 철학의 핵심
```
좋은 설계 = 예외가 없는 설계
나쁜 설계 = 예외로 가득한 설계
```

**"복잡한 예외 처리가 필요하다면, 설계가 틀렸다"**

### 그래프 설계 원칙들
1. **노드 유일성 보장**: 같은 물리적 위치 = 같은 노드 ID
2. **적절한 표현 방식 선택**: 문제 특성에 맞는 그래프 표현법 사용
3. **체계적 ID 부여**: 구역별, 역할별로 ID 범위 분리
4. **검증 과정**: 설계 완료 후 유일성과 연결성 검증

### 임시방편의 함정
아무리 똑똑하게 예외 처리해도 **근본 설계가 틀렸으면 반드시 놓치는 케이스가 발생**한다.

### 앞으로의 접근법
복잡한 그래프 문제를 만나면:
1. **먼저** 유일성 원칙부터 확인 
2. **적절한** 그래프 표현 방식 선택
3. **절대** 임시방편적 예외 처리로 해결하려 하지 말기
4. **복잡해지면** 설계를 다시 검토하기

## 마무리

이 문제는 알고리즘 문제이지만 실제로는 **소프트웨어 설계 능력**을 묻는 문제였다.

특히 **그래프 표현 방법론**과 **노드 유일성 원칙**을 체계적으로 적용하는 능력이 핵심이었다. 코딩 실력보다 **"올바른 추상화 설계 능력"**이 훨씬 더 중요했고, 특히 **노드 유일성 원칙**을 처음부터 고려하지 않으면 아무리 노력해도 해결할 수 없는 문제였다.

**복잡한 문제일수록 단순하고 직관적인 설계가 승부를 가른다.**
