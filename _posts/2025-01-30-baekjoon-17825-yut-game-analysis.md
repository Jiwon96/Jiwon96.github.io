---
layout: post
title: "백준 17825 주사위 윷놀이 - 노드 유일성 원칙과 그래프 설계의 중요성"
date: 2025-01-30
categories: [Algorithm, 백준]
tags: [백트래킹, 그래프, 설계, 추상화]
---

## 들어가며

백준 17825번 주사위 윷놀이 문제를 풀면서 겪은 뼈아픈 실패 경험을 통해 **그래프 설계의 중요성**과 **노드 유일성 원칙**에 대해 깊이 있게 분석해보고자 한다.

단순해 보이는 백트래킹 문제였지만, 실제로는 **"어떻게 그래프를 설계하느냐"**가 모든 것을 결정하는 문제였다.

## 내가 처음 작성한 코드의 문제점

### 기본 접근 방식
처음에는 4개의 트랙을 분리해서 관리하는 방식으로 접근했다:

```python
track[0] = [빨간 트랙]  # [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,-1]
track[1] = [파란 트랙1] # [10,13,16,19,25,30,35,40,-1]
track[2] = [파란 트랙2] # [20,22,24,25,30,35,40,-1] 
track[3] = [파란 트랙3] # [30,28,27,26,25,30,35,40,-1]
```

각 말의 위치를 `(트랙번호, 위치)` 형태로 관리했다.

### 치명적인 중복 체크 버그

가장 큰 문제는 빨간 트랙과 파란 트랙 간의 중복 체크 로직이었다:

```python
else: # 하나는 빨간, 하나는 파란
    if (t[other_player][1], t[other_player][0]) == (cur_track, cur_pos):
        is_duplicate = True
```

**문제**: 빨간 트랙(0)과 파란 트랙(1,2,3)은 트랙 번호가 다르므로 이 조건은 **절대 True가 될 수 없다**!

결과적으로 빨간-파란 트랙 간의 중복이 전혀 체크되지 않았다.

## 핵심 패인: 유일성 부재가 만든 복잡성의 악순환

### 진짜 문제의 뿌리
```
유일성 부재 → 복잡한 예외 처리 → 버그 연쇄 발생 → 디버깅 지옥
```

### 내가 겪은 설계 실패의 전형적 패턴
1. **초기 설계**: (트랙, 위치) 방식으로 "간단하게" 시작
2. **문제 발견**: 중복 체크가 복잡함을 깨달음
3. **임시방편**: 케이스별로 예외 처리 추가
   ```python
   if 둘다파란: ...
   elif 둘다빨간: ...  
   else: # 하나는 빨간, 하나는 파란
       if 40점: ...
       elif 30점: ...
       else: ... # 여기서 버그!
   ```
4. **악순환**: 예외 처리가 계속 늘어나고 버그도 계속 발생
5. **포기**: 복잡한 로직에 매몰되어 근본 원인을 못 찾음

### 유일성 설계의 결정적 중요성
**"처음 설계가 모든 것을 결정한다"**

- ✅ **올바른 설계**: 유일성 보장 → 단순한 로직 → 버그 없음
- ❌ **잘못된 설계**: 유일성 부재 → 복잡한 예외처리 → 버그 연쇄

## 점수 기반 중복 체크의 한계

내가 버그를 "수정"한다고 시도한 방법:

```python
# 점수가 같으면 중복으로 간주
if track[t[other_player][1]][t[other_player][0]] == track[cur_track][cur_pos]:
    is_duplicate = True
```

하지만 이 접근도 근본적 한계가 있었다.

### 30점의 이중성 문제
윷놀이 보드에는 **30점이 두 곳**에 존재한다:
- **15번 분기점**: 빨간트랙(0,15) = 파란트랙3(3,0) = 30점
- **합류점**: 모든 파란트랙이 합류한 후의 30점

```python
# 실제 발생하는 문제
말A: 15번 분기점의 30점 (분기점)
말B: 합류점의 30점 (25→30으로 이동)
# 다른 물리적 위치인데 점수가 같아서 중복으로 잘못 판정!
```

### 기타 점수 중복 사례들
```python
빨간트랙 22점(0,11) vs 파란트랙2 22점(2,1)  # 다른 위치, 같은 점수
빨간트랙 24점(0,12) vs 파란트랙2 24점(2,2)  # 다른 위치, 같은 점수
빨간트랙 26점(0,13) vs 파란트랙3 26점(3,3)  # 다른 위치, 같은 점수
```

**결론**: **같은 점수 ≠ 같은 물리적 위치**

## 올바른 해결책: 통합 인덱스 방식

### 노드 유일성의 정의
- **같은 물리적 위치 = 반드시 같은 노드 표현**
- **다른 물리적 위치 = 반드시 다른 노드 표현**
- **점수는 노드의 속성일 뿐, 식별자가 아님**

### 올바른 그래프 설계

```python
# 모든 칸에 고유한 인덱스 부여
graph = [[1], [2], [3], [4], [5],           # 0~4: 시작~8점
         [6, 21], [7], [8], [9], [10],      # 5~9: 10점(분기)~18점  
         [11, 25], [12], [13], [14], [15],  # 10~14: 20점(분기)~28점
         [16, 27], [17], [18], [19], [20],  # 15~19: 30점(분기)~38점
         [32], [22], [23], [24], [30],      # 20~24: 40점, 파란1경로
         [26], [24], [28], [29], [24],      # 25~29: 파란2경로, 파란3경로  
         [31], [20], [32]]                   # 30~32: 합류경로, 도착

score = [0, 2, 4, 6, 8,           # 각 노드의 점수
         10, 12, 14, 16, 18,
         20, 22, 24, 26, 28,
         30, 32, 34, 36, 38,
         40, 13, 16, 19, 25,
         22, 24, 28, 27, 26,
         30, 35, 0]
```

### 완벽한 정답 코드

```python
def backtrack(depth, current_score, horses):
    global max_score
    
    if depth == 10:
        max_score = max(max_score, current_score)
        return
    
    for i in range(4):
        current_pos = horses[i]
        
        if current_pos == 32:  # 이미 도착한 말
            continue
        
        # 다음 위치 계산
        if len(graph[current_pos]) == 2:  # 분기점
            next_pos = graph[current_pos][1]  # 파란 경로
        else:
            next_pos = graph[current_pos][0]  # 일반 경로
        
        # 주사위 값만큼 이동
        for _ in range(1, dice[depth]):
            if next_pos != 32:
                next_pos = graph[next_pos][0]
        
        # 중복 체크: 이것이 핵심!
        if next_pos == 32 or (next_pos < 32 and next_pos not in horses):
            original_pos = horses[i]
            horses[i] = next_pos
            
            backtrack(depth + 1, current_score + score[next_pos], horses)
            
            horses[i] = original_pos

dice = list(map(int, input().split()))
max_score = 0
backtrack(0, 0, [0, 0, 0, 0])
print(max_score)
```

### 중복 체크의 혁신적 단순화

```python
# ❌ 내 원래 코드: 복잡한 케이스 분류
if t[other_player][1] > 0 and cur_track > 0:
    # 둘 다 파란트랙...
elif t[other_player][1] == 0 and cur_track == 0:
    # 둘 다 빨간트랙...
else:
    # 하나는 빨간, 하나는 파란... (버그 발생)

# ✅ 정답 코드: 단순한 한 줄
if next_pos not in horses:
    # 이동 가능!
```

## 핵심 교훈

### 가장 중요한 깨달음
```
점수 = 노드의 속성 (Property)
점수 ≠ 노드의 식별자 (Identity)

같은 점수 ≠ 같은 물리적 위치
```

### 설계 철학의 핵심
```
좋은 설계 = 예외가 없는 설계
나쁜 설계 = 예외로 가득한 설계
```

**"복잡한 예외 처리가 필요하다면, 설계가 틀렸다"**

### 임시방편의 함정
아무리 똑똑하게 예외 처리해도 **근본 설계가 틀렸으면 반드시 놓치는 케이스가 발생**한다.

### 앞으로의 접근법
복잡한 그래프 문제를 만나면:
1. **먼저** 유일성 원칙부터 확인 
2. **절대** 임시방편적 예외 처리로 해결하려 하지 말기
3. **복잡해지면** 설계를 다시 검토하기

## 마무리

이 문제는 알고리즘 문제이지만 실제로는 **소프트웨어 설계 능력**을 묻는 문제였다.

코딩 실력보다 **"올바른 추상화 설계 능력"**이 훨씬 더 중요했고, 특히 **노드 유일성 원칙**을 처음부터 고려하지 않으면 아무리 노력해도 해결할 수 없는 문제였다.

**복잡한 문제일수록 단순하고 직관적인 설계가 승부를 가른다.**
