---
layout: post
title: "백준 - 상어 중학교: 효율적인 구현을 위한 핵심 테크닉"
date: 2025-07-22
categories: [Algorithm, 백준]
---

# 백준 - 상어 중학교: 효율적인 구현을 위한 핵심 테크닉

## 들어가며
처음 이 문제를 풀 때는 단순하게 접근했지만, 정답 코드를 분석해보니 훨씬 효율적이고 깔끔한 구현 방법들이 있었습니다. 특히 **경계 처리**, **무지개 블록의 중복 처리**, **중력 구현** 부분에서 많은 것을 배웠습니다.

## 내가 처음에 놓쳤던 부분들

### 1. 복잡한 경계 처리
- `0<=nr<N and 0<=nc<N` 같은 조건을 매번 체크
- 실수하기 쉽고 코드가 복잡해짐

### 2. 비효율적인 무지개 블록 처리
- 별도의 `rainbow_v` 리스트로 무지개 블록을 관리
- BFS 후 무지개 블록만 다시 초기화하는 복잡한 로직

### 3. 단순한 중력 구현
- 한 번에 한 칸씩만 이동시키는 비효율적 방법

## 정답 코드에서 배운 핵심 테크닉들

### 1. 패딩을 통한 경계 처리 제거
```python
# 4방향을 -1로 둘러쌈 (범위체크 필요없음)
arr = [[-1]*(N+2)]+[[-1]+list(map(int, input().split()))+[-1] for _ in range(N)]+[[-1]*(N+2)]
```
- 배열 주변을 -1로 패딩하여 경계 체크를 완전히 제거
- 코드가 간결해지고 실수 가능성이 줄어듦

### 2. 무지개 블록 중복 처리의 핵심: 전역 vs 지역 관리

**가장 중요한 변수 선언 위치:**
```python
v = [[0]*(N+2) for _ in range(N+2)]  # 전역 - BFS 함수 밖에서 선언
mx_group = set()
mx_rcnt=0
for si in range(1,N+1):
    for sj in range(1,N+1):
        if v[si][sj]==0 and 0<arr[si][sj]<=M:   # 미방문 일반블럭
            q = deque()
            group=set()  # 지역 - 각 BFS마다 새로 생성
```

**핵심 아이디어:**
- **`v` 배열**: BFS 함수 **밖에서** 선언 → **전역 상태**
- **`group` 집합**: 각 BFS **안에서** 선언 → **지역 상태**

**왜 set을 사용했을까?**
- **`group = set()`**: 좌표 튜플 `(row, col)`의 중복 체크를 O(1)에 처리
- 리스트로 하면 `(ni,nj) not in group`이 O(n) → 비효율적
- set을 사용하면 중복 체크가 O(1) → 효율적

**두 단계 중복 방지 메커니즘:**
```python
if v[ni][nj]==0 and (ni,nj) not in group and (arr[ni][nj]==color or arr[ni][nj]==0):
    if arr[ni][nj]==0:  # 무지개인경우
        r_cnt+=1
    else:               # 일반블록
        v[ni][nj]=1  # 전역에 기록
```

- **`v` 배열 (전역)**: 일반 블록만 표시하여 다른 그룹에서 재사용 방지
- **`group` 집합 (지역)**: 현재 BFS 내에서만 중복 방지, 매번 새로 생성

**왜 이렇게 할까?**
- 무지개 블록은 여러 그룹에 속할 수 있어야 함 (전역에 기록하지 않음)
- 하지만 같은 그룹 내에서는 중복되면 안 됨 (지역 set으로 관리)
- 일반 블록은 한 번만 사용 가능 (전역에 기록)

### 3. 연쇄적 중력 처리

**내가 이해한 방식:** "도미노처럼 위에서부터 차례대로 떨어뜨리기"

```python
def gravity():
    for si in range(1,N):        # 모든 칸을 위에서부터 순회
        for sj in range(1,N+1):  
            ci,cj=si,sj          # 현재 위치에서 시작
            # 내가 블럭이고 && 밑칸이 빈칸이면
            while 0<=arr[ci][cj]<=M and arr[ci+1][cj]==EMPTY:
                arr[ci][cj],arr[ci+1][cj]=arr[ci+1][cj],arr[ci][cj]  # 나랑 밑칸 교환
                ci-=1  # 한 칸 위로 올라가서 다시 확인
```

**핵심:** `ci-=1`로 연쇄 반응 처리
- 내가 아래로 떨어지면 → 내 자리가 빔
- 내 위쪽 블럭도 → 이제 떨어질 수 있음
- 그래서 → 한 칸 위로 올라가서 다시 확인

## 마치며
이 문제를 통해 **패딩을 통한 경계 처리**, **상태별 중복 관리**, **연쇄적 처리** 같은 구현 테크닉들을 배웠습니다. 특히 무지개 블록 처리에서 전역과 지역 상태를 분리하여 관리하는 방식과 set을 활용한 효율적인 중복 체크는 다른 문제에서도 응용할 수 있을 것 같습니다.
