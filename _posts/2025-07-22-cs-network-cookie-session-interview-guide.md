---
layout: post
title: "CS Network 면접 대비 - 쿠키, 세션, HTTP 무상태성 완벽 가이드"
date: 2025-07-22
categories: [CS, Network]
tags: [cookie, session, http, stateless, authentication, interview]
---

# 쿠키와 세션의 차이점부터 멀티서버 세션 관리까지

네트워크 기초 개념 중 면접에서 자주 출제되는 **쿠키와 세션**, **HTTP 무상태성**, **분산 환경에서의 세션 관리** 등을 체계적으로 정리했습니다.

## 1. 쿠키와 세션의 차이에 대해 설명해 주세요

**쿠키(Cookie)**와 **세션(Session)**은 모두 HTTP의 **무상태성(Stateless)** 특성을 보완하기 위해 사용되는 상태 유지 방법입니다.

**쿠키**는 **클라이언트 측**에 저장되는 작은 데이터 파일로, 브라우저가 서버로 요청을 보낼 때마다 자동으로 함께 전송됩니다. 반면 **세션**은 **서버 측**에 사용자 정보를 저장하고, 클라이언트에는 **세션 ID**만을 쿠키나 URL 파라미터로 전달합니다.

주요 차이점은 **보안성**, **저장 위치**, **용량 제한**입니다. 쿠키는 클라이언트에 노출되어 보안에 취약하지만, 세션은 서버에서 관리되어 상대적으로 안전합니다.

### 간략버전
- **쿠키**: **클라이언트 저장**, 자동 전송, 보안 취약
- **세션**: **서버 저장**, **세션 ID**만 전달, 상대적 안전
- 둘 다 HTTP **무상태성** 보완 목적

---

## 2. 세션 방식의 로그인 과정에 대해 설명해 주세요

앞서 설명한 **세션**을 활용한 로그인 과정은 다음과 같습니다:

1. 사용자가 **로그인 정보**(ID/PW)를 서버에 전송
2. 서버가 인증 정보를 검증 후, **고유한 세션 ID**를 생성
3. 서버는 **세션 저장소**에 세션 ID와 사용자 정보를 매핑하여 저장
4. 생성된 **세션 ID를 쿠키**로 클라이언트에게 전송
5. 이후 요청 시 클라이언트는 세션 ID 쿠키를 자동으로 전송
6. 서버는 세션 ID로 저장된 사용자 정보를 조회하여 **인증 상태를 확인**

이 과정을 통해 HTTP의 **무상태성**을 극복하고 로그인 상태를 유지할 수 있습니다.

### 간략버전
1. 로그인 정보 전송 → 2. **세션 ID** 생성 → 3. **세션 저장소**에 매핑 저장
4. 세션 ID **쿠키** 전송 → 5. 이후 요청마다 자동 전송 → 6. **인증 상태 확인**

---

## 3. HTTP의 특성인 Stateless에 대해 설명해 주세요

**Stateless(무상태성)**는 HTTP 프로토콜의 핵심 특성으로, 서버가 클라이언트의 **이전 요청에 대한 정보를 기억하지 않는다**는 의미입니다.

각각의 HTTP 요청은 **독립적**이며, 서버는 요청을 처리한 후 클라이언트의 상태 정보를 저장하지 않습니다. 따라서 이전에 로그인했더라도, 다음 요청에서는 그 정보를 알 수 없습니다.

이러한 특성은 **서버의 확장성**과 **단순성**을 제공하지만, 앞서 언급한 **쿠키와 세션** 같은 별도의 메커니즘 없이는 사용자의 로그인 상태나 장바구니 정보 등을 유지할 수 없다는 한계가 있습니다.

### 간략버전
- **무상태성**: 서버가 **이전 요청 정보를 기억하지 않음**
- 각 요청은 **독립적**
- 장점: **확장성**, **단순성** / 단점: 상태 유지 어려움

---

## 4. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

좋은 지적입니다. **Stateless 원칙**을 엄격히 적용하면 서버에 상태를 저장하는 **세션 방식**은 모순적으로 보일 수 있습니다.

하지만 실제로는 **순수한 Stateless**와 **실용적인 상태 관리** 사이의 **트레이드오프**입니다. 완전한 무상태를 유지하려면 매번 인증 정보를 전송해야 하는데, 이는 **보안상 위험**하고 **비효율적**입니다.

이런 문제를 해결하기 위해 **JWT(JSON Web Token)** 같은 **토큰 기반 인증**이 등장했습니다. JWT는 필요한 정보를 **토큰 자체에 포함**시켜 서버가 상태를 저장하지 않으면서도 인증을 처리할 수 있어, HTTP의 **Stateless 특성을 더 잘 준수**합니다.

세션은 Stateless 원칙에 완벽히 부합하지는 않지만, **단순성과 보안성** 측면에서 여전히 널리 사용되는 실용적인 방법입니다.

### 간략버전
- 세션은 **Stateless 원칙에 모순**적으로 보임
- 실제로는 **실용성과 보안성**의 **트레이드오프**
- **JWT** 같은 **토큰 기반 인증**이 더 Stateless에 부합
- 세션은 여전히 **실용적인 방법**

---

## 5. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

앞서 언급한 **세션의 서버 측 저장** 특성으로 인해 **멀티 서버 환경**에서는 세션 관리가 복잡해집니다. 사용자가 서버 A에서 로그인했는데 다음 요청이 서버 B로 라우팅되면 세션을 찾을 수 없는 문제가 발생합니다.

주요 해결 방법들은:

**1. Sticky Session (Session Affinity)**
**로드밸런서**가 특정 사용자의 요청을 항상 같은 서버로 라우팅. 간단하지만 서버 장애 시 세션 손실 위험이 있습니다.

**2. Session Clustering**
여러 서버 간 **세션 정보를 복제**하여 공유. **WAS 클러스터링** 기능을 활용합니다.

**3. 중앙화된 세션 저장소**
**Redis**나 **Memcached** 같은 **인메모리 DB**에 모든 세션을 중앙 관리. 가장 일반적인 해결책입니다.

**4. 토큰 기반 인증**
앞서 언급한 **JWT** 방식으로 전환하여 **서버 상태 의존성 제거**합니다.

**Redis를 활용한 중앙 세션 관리**가 가장 널리 사용되는 방법으로, **확장성**과 **성능**, **가용성**을 모두 만족시킬 수 있습니다.

### 간략버전
**멀티 서버 환경**에서의 세션 관리 방법:
1. **Sticky Session**: 같은 서버로 라우팅
2. **Session Clustering**: 서버 간 세션 복제
3. **중앙 세션 저장소**: **Redis** 활용 (권장)
4. **토큰 기반 인증**: **JWT** 사용

---

## 핵심 키워드 정리

- **쿠키(Cookie)**, **세션(Session)**
- **무상태성(Stateless)**
- **세션 ID**, **클라이언트 측**, **서버 측**
- **JWT(JSON Web Token)**, **토큰 기반 인증**
- **멀티 서버 환경**, **Redis**, **로드밸런서**
- **Session Clustering**, **중앙화된 세션 저장소**

이러한 개념들은 웹 개발에서 인증과 상태 관리의 핵심이며, 시스템 설계 면접에서도 자주 다뤄지는 중요한 주제입니다.
