---
layout: post
title: "백준 17822번 원판 돌리기 - 참조변수와 수정변수 분리의 중요성"
date: 2025-06-21 12:00:00 +0900
categories: [Algorithm, 백준]
tags: [백준, 시뮬레이션, 알고리즘, 원판돌리기]
---

# 백준 17822번 원판 돌리기 - 참조변수와 수정변수 분리의 중요성

## 문제 상황과 초기 접근

백준 17822번 원판 돌리기 문제를 풀면서 시뮬레이션 알고리즘의 핵심적인 개념을 깨달았다. 이 문제는 단순해 보이지만, 배열의 동시 업데이트라는 함정이 숨어있는 문제였다.

## 내가 겪었던 실수와 문제점

처음 코드를 작성할 때 다음과 같은 안좋은 습관들이 있었다:

### 1. 단일 책임 원칙 위반
```python
# 나쁜 예: 하나의 함수가 너무 많은 일을 담당
def solve():
    # 회전 + 인접 확인 + 제거 + 평균 계산 + 업데이트
    # 모든 로직이 한 곳에 몰려있음
```

### 2. 참조변수와 수정변수 미분리
```python
# 위험한 패턴: 같은 배열을 참조하면서 동시에 수정
for i in range(N):
    for j in range(M):
        if arr[i][j] == arr[next_i][next_j]:  # 참조
            arr[i][j] = 0  # 동시에 수정 - 문제 발생!
```

### 3. 변수명의 모호성
```python
v = []  # 무엇을 의미하는지 불분명
s = 0   # 합계? 시작? 
c = 0   # 개수? 카운터?
```

## 핵심 깨달음: 참조변수와 수정변수 분리

### 문제의 핵심
원판에 수가 남아 있으면, 인접하면서 수가 같은 것을 모두 찾는다. 그러한 수가 있는 경우에는 원판에서 인접하면서 같은 수를 모두 지운다.

이 부분에서 **동시성 문제**가 발생한다. 인접한 값들을 확인하는 동안 원본 데이터가 변경되면, 잘못된 결과가 나올 수 있다.

### 해결 방법: 참조/수정 변수 분리 패턴

```python
# 올바른 패턴
def process_array():
    original_arr = current_state    # 참조용 (읽기 전용)
    next_arr = [row[:] for row in original_arr]  # 수정용
    
    for i in range(N):
        for j in range(M):
            # 판단은 original_arr로
            if should_update(original_arr, i, j):
                # 수정은 next_arr로
                next_arr[i][j] = new_value
    
    return next_arr
```

### 내가 사용한 해결책

```python
def lstnear(lst, r):
    l = lst[:]  # 복사본 생성
    for j in range(M):
        if arr[r][j] == 0: continue
        for d in range(4):
            nr, nc = r+dr[d], (j+dc[d])%M
            if 0<=nr<N and lst[j] == arr[nr][nc]:  # arr로 참조
                l[j] = 0  # l에만 수정
    return l
```

주석에서 강조한 부분들:
> "참조변수(arr)로 비교하고 수정변수(tarr)에만 수정할것"

> "어떻게 lst, r만 매개변수로 주면서 인접 요소와 같이 0을 만들까? => 내가 어떤 인자랑 인접하면, 어떤 인자도 나랑 인접함 => 참조변수만 수정되지 않으면 lst[nr][nc] -> lst[r][c]를 참조할 것"

### 핵심 아이디어: 대칭성을 이용한 일관적인 프로세스

이 접근법의 핵심은 **인접 관계의 대칭성**을 활용한 것이다. `lst`(현재 행)와 `r`(행 번호)만을 매개변수로 받으면서도 모든 인접한 같은 값들을 제거할 수 있는 이유:

1. **대칭성 원리**: A가 B와 인접하면, B도 A와 인접하다
2. **일관적인 참조점**: 모든 행이 같은 원본 배열(`arr`)을 참조하므로 일관된 판단 기준 유지  
3. **자동 동기화**: 현재 위치(`lst[j]`)만 업데이트해도 자동으로 일관적인 프로세싱이 가능

```python
# 행 i에서: arr[i][j] == arr[i+1][k] 확인 → lst_i[j] = 0
# 행 i+1에서: arr[i+1][k] == arr[i][j] 확인 → lst_i+1[k] = 0
# 결과: 양쪽 모두 0으로 설정됨 (대칭적 제거)
```

**왜 현재 위치만 업데이트해도 될까?**
바로 **대칭성** 때문이다. 내가 인접한 다른 위치를 직접 수정할 필요가 없다. 그 위치를 담당하는 함수 호출에서 자연스럽게 나를 확인하고 자신을 업데이트할 것이기 때문이다. 이로 인해:

- 각 행은 **자신의 상태만 책임**지면 됨 (단일 책임)
- 전체적으로는 **완벽하게 동기화**된 업데이트 (일관적 프로세스)
- 복잡한 전역 상태 관리 불필요

이는 **단일 책임 원칙**과 **일관적인 프로세스**를 동시에 만족하는 우아한 해결책이다.

## 시뮬레이션 알고리즘에서 이 패턴이 중요한 이유

### 1. 데이터 무결성 보장
- 원본 데이터가 중간에 변경되지 않아 일관된 판단 기준 유지
- Race condition 방지

### 2. 디버깅 용이성
- 어떤 시점의 데이터를 기준으로 판단했는지 명확
- 중간 상태 추적 가능

### 3. 함수의 예측 가능성
- 입력이 같으면 항상 같은 출력 보장
- 부작용(side effect) 최소화

## 개선된 코드 구조

### Before: 복잡하고 위험한 구조
```python
def solve():
    # 모든 로직이 한 곳에
    # 전역 변수 직접 수정
    # 참조와 수정이 뒤섞임
```

### After: 명확하고 안전한 구조
```python
def rotate_disk(disk, is_clockwise, steps):
    """단일 책임: 회전만 담당"""
    
def has_adjacent_same_values(disk, row_idx, original_board):
    """단일 책임: 인접 확인만 담당"""
    
def remove_adjacent_same_values(disk, row_idx, original_board):
    """단일 책임: 제거만 담당"""
    # original_board로 참조, 새로운 disk 반환

def solve():
    for turn in range(T):
        # 1. 회전
        # 2. 인접 확인 (참조용 board 사용)
        # 3. 새로운 상태 생성 (수정용 next_board)
        # 4. 상태 교체
        board = next_board
```

## 다른 문제에서의 적용

이 패턴은 시뮬레이션 문제에서 자주 나타난다:

- **게임 상태 업데이트**: 모든 캐릭터가 동시에 행동
- **셀룰러 오토마타**: Conway's Game of Life 등
- **격자 기반 시뮬레이션**: 바이러스 확산, 불 번짐 등

## 교훈

1. **단일 책임 원칙**: 각 함수는 하나의 명확한 역할만
2. **참조/수정 분리**: 읽기용과 쓰기용 변수를 명확히 구분
3. **변수명 명확화**: 코드의 의도를 즉시 파악할 수 있도록
4. **불변성 존중**: 원본 데이터를 보호하고 새로운 상태 생성

시뮬레이션 문제에서는 "동시성"이 핵심이다. 모든 변화가 같은 시점을 기준으로 일어나야 하며, 이를 위해서는 참조변수와 수정변수를 철저히 분리해야 한다. 이 원칙만 지켜도 복잡한 시뮬레이션 문제를 훨씬 안전하고 명확하게 해결할 수 있다.