---
layout: post
title: "페이지 교체 알고리즘 및 스래싱"
date: 2025-01-24
categories: [CS, OS]
tags: [운영체제, 페이지교체, 스래싱, LRU, FIFO, 메모리관리]
---

# 페이지 교체 알고리즘 및 스래싱

## 간략 버전

### 1. 페이지 교체 알고리즘 개요
- **정의**: 물리 메모리 부족 시 어떤 페이지를 디스크로 스왑아웃할지 결정하는 알고리즘
- **목적**: **페이지 폴트** 최소화를 통한 시스템 성능 최적화

### 2. 주요 페이지 교체 알고리즘

#### FIFO (First-In-First-Out)
- **특성**: 가장 먼저 들어온 페이지를 교체
- **구현**: **원형 큐** 사용
- **단점**: **Belady의 이상현상** 발생 가능 (프레임 증가해도 페이지 폴트 증가)

**예제**: 참조열 [1,2,3,4,1,2,5,1,2,3,4,5], 프레임=3
```
페이지: 1 2 3 4 1 2 5 1 2 3 4 5
프레임1: 1 1 1 4 4 4 5 5 5 3 3 3
프레임2:   2 2 2 1 1 1 1 1 1 4 4
프레임3:     3 3 3 2 2 2 2 2 2 5
폴트:   F F F F F F F   F F F F
```

#### 최적 알고리즘 (OPT)
- **특성**: 미래에 가장 늦게 사용될 페이지를 교체
- **장점**: 이론적 최적해, 성능 비교 기준
- **단점**: 미래 정보 필요로 **실구현 불가능**

#### LRU (Least Recently Used)
- **특성**: **시간적 지역성** 원리 활용, 가장 오랫동안 사용되지 않은 페이지 교체
- **구현 방법**:
  - **카운터 방식**: 각 페이지마다 타임스탬프
  - **스택 방식**: 더블 링크드 리스트
  - **하드웨어 지원**: 참조 비트와 참조 시간 레지스터

#### Clock 알고리즘 (Second-Chance)
- **특성**: **FIFO + 참조 비트**의 결합으로 LRU 근사
- **동작**: 참조 비트가 1이면 0으로 만들고 다음으로, 0이면 교체
- **장점**: LRU보다 **낮은 오버헤드**

#### Enhanced Clock 알고리즘
- **특성**: **참조 비트(R)**와 **수정 비트(M)** 함께 사용
- **4가지 클래스**: (0,0) → (0,1) → (1,0) → (1,1) 순으로 교체
- **장점**: 수정된 페이지의 디스크 쓰기 비용 고려

#### Working Set 알고리즘
- **특성**: **지역성 원리** 기반, 프로세스의 **워킹셋** 유지
- **Working Set**: 최근 Δ번의 참조에서 나타난 페이지들의 집합
- **목적**: **스래싱 방지**

### 3. LRU 알고리즘 특성 및 한계

#### LRU가 활용하는 특성: **시간적 지역성 (Temporal Locality)**
- 최근에 참조된 페이지가 다시 참조될 가능성이 높다는 원리

#### LRU 구현 방법:
**스택 방식 예제**: 참조열 [1,2,3,2,4,1,2]
```
참조 1: [1]
참조 2: [2,1] 
참조 3: [3,2,1]
참조 2: [2,3,1] (2를 맨 위로)
참조 4: [4,2,3] (1 교체)
```

#### LRU의 단점:
- **높은 오버헤드**: 매 참조마다 순서 정보 업데이트 필요
- **하드웨어 지원 필요**: 효율적 구현을 위한 특별한 하드웨어
- **스캔 저항성 부족**: 순차적 접근 시 **버퍼 오염** 발생

#### LRU 대안 알고리즘:
- **Clock 알고리즘**: 참조 비트만 사용하여 오버헤드 감소
- **Working Set 알고리즘**: 지역성을 더 정확히 반영
- **WSClock 알고리즘**: Working Set과 Clock의 결합

### 4. 스래싱 (Thrashing)

#### 정의: 
시스템이 실제 작업보다 **페이지 스와핑**에 더 많은 시간을 소비하는 현상

#### 발생 원인:
```
다중프로그래밍 정도 증가 → 각 프로세스 할당 프레임 감소 
→ Working Set > 할당 프레임 → 빈번한 페이지 폴트 
→ 계속적인 I/O 대기 → CPU 이용률 급감
```

#### 스래싱 예제: 
메모리 512MB, 프로세스 10개 → 20개 증가 상황
- **정상 상태**: 각 50MB 할당, Working Set 40MB
  - CPU 이용률 85%, 페이지 폴트 50회/초
- **스래싱 상태**: 각 25MB 할당, Working Set 40MB  
  - CPU 이용률 15%, 페이지 폴트 500회/초

#### 성능 저하 원리:
```
정상: 메모리 참조 10,000회/초, 성공률 99.5%
스래싱: 메모리 참조 2,000회/초, 성공률 75%
→ Working Set을 메모리에 유지할 수 없어 계속적인 교체 발생
```

### 5. 스래싱 완화 방법

#### Working Set 모델:
- 각 프로세스의 **Working Set 크기** 모니터링
- 전체 Working Set 요구량 > 물리 메모리 시 프로세스 **스왑아웃**

#### 페이지 폴트 빈도 (PFF) 모델:
- **상한/하한 임계값** 설정으로 동적 프레임 할당
- 폴트율 > 상한 시: 프레임 추가 또는 프로세스 스왑아웃
- 폴트율 < 하한 시: 프레임 회수

#### 다중프로그래밍 정도 제어:
- CPU 이용률 < 임계값 && 페이지 폴트율 > 임계값 시 **스래싱 탐지**
- 일부 프로세스 일시 중단으로 메모리 압박 완화

#### 메모리 할당 정책 개선:
- **지역 할당**: 각 프로세스 고정 프레임 풀
- **비례 할당**: 프로세스 크기에 비례한 할당
- **우선순위 할당**: 중요도 기반 차등 할당

---

## 상세 버전 (이해용)

### 1. 페이지 교체 알고리즘 성능 비교

#### 동일 조건 테스트: 
참조열 [7,0,1,2,0,3,0,4,2,3,0,3,2], 프레임=3

**FIFO**: 10회 페이지 폴트
- Belady의 이상현상으로 비효율적
- 지역성 무시로 Working Set 보호 못함

**LRU**: 9회 페이지 폴트  
- 시간적 지역성 활용으로 FIFO보다 우수
- 하지만 순차 접근에서는 비효율적

**최적 알고리즘**: 7회 페이지 폴트
- 이론적 최적해, 다른 알고리즘의 성능 상한선

### 2. 지역성 패턴별 알고리즘 성능

#### 반복 접근 패턴 [1,2,3,1,2,3,1,2,3...]:
- **LRU 우수**: Working Set이 메모리에 잘 유지됨
- **FIFO 보통**: 일부 불필요한 교체 발생

#### 순차 접근 패턴 [1,2,3,4,5,6,7,8,9...]:
- **FIFO 우수**: 순차적 특성과 일치
- **LRU 불량**: 스캔 저항성 부족으로 버퍼 오염

#### 랜덤 접근 패턴 [7,2,9,1,5,8,3,6...]:
- **모든 알고리즘 유사**: 지역성 없어 예측 불가능

### 3. Clock 알고리즘 상세 동작

#### 시나리오: 
메모리에 페이지 [A,B,C,D], 새 페이지 E 적재

#### 동작 과정:
```
1라운드:
포인터 → A: 참조 비트 1 → 0 변경, 다음
포인터 → B: 참조 비트 1 → 0 변경, 다음  
포인터 → C: 참조 비트 0 → C를 E로 교체

특징: 모든 페이지가 "두 번째 기회" 획득
```

### 4. Enhanced Clock의 교체 우선순위

#### 4가지 클래스 예제:
- 페이지 A: (R=0, M=0) - 읽기 전용, 최근 미사용 → **1순위 교체**
- 페이지 B: (R=0, M=1) - 수정됨, 최근 미사용 → 2순위  
- 페이지 C: (R=1, M=0) - 읽기 전용, 최근 사용 → 3순위
- 페이지 D: (R=1, M=1) - 수정됨, 최근 사용 → **최후순위**

**장점**: 수정된 페이지의 디스크 쓰기 비용 최소화

### 5. Working Set 모델 상세

#### Working Set 계산 예제: 
Δ = 5, 참조열: [1,2,3,4,1,2,5,1,2,3]

```
시점 t=6: WS = {1,2,3,4,5} (크기 5)
시점 t=8: WS = {1,2,5} (크기 3)
시점 t=10: WS = {1,2,3} (크기 3)
```

#### Working Set 기반 메모리 관리:
- 전체 Working Set 요구량 계산
- 물리 메모리 부족 시 낮은 우선순위 프로세스 스왑아웃
- 각 프로세스의 Working Set이 메모리에 유지되도록 보장

### 6. 스래싱 발생 메커니즘 상세

#### 도서관 비유로 이해:
- **정상**: 책상에 필요한 책 20권 모두 배치 가능
  - 실제 공부 51분, 책 가져오기 9분 (85% 효율)
- **스래싱**: 책상에 10권만 배치 가능, 여전히 20권 필요
  - 실제 공부 9분, 책 바꾸기 51분 (15% 효율)

#### 실제 측정값 분석:
```
정상 상태:
- 메모리 참조: 10,000회/초
- 페이지 폴트: 50회 (0.5%)
- I/O 대기: 150ms (15%)
- CPU 활용: 850ms (85%)

스래싱 상태:  
- 메모리 참조: 2,000회/초 (처리능력 저하)
- 페이지 폴트: 500회 (25%)
- I/O 대기: 850ms (85%)
- CPU 활용: 150ms (15%)
```

### 7. 스래싱 완화 전략 상세

#### PFF 기반 동적 제어:
```
각 프로세스별 페이지 폴트율 모니터링:
- 상한 임계값(15회/초) 초과 시: 메모리 추가 할당
- 하한 임계값(5회/초) 미만 시: 메모리 회수
- 전체 메모리 부족 시: 낮은 우선순위 프로세스 스왑아웃
```

#### 적응적 메모리 할당 정책:
- **균등 할당**: 모든 프로세스에 동일한 프레임 수
- **비례 할당**: 프로세스 크기에 비례한 할당
- **우선순위 할당**: 중요 프로세스에 더 많은 메모리

#### 실시간 모니터링 지표:
- CPU 이용률, 페이지 폴트율, I/O 대기율 종합 분석
- 임계값 초과 시 즉시 다중프로그래밍 정도 조정

---

## 핵심 질문 및 답변

### Q1: 페이지 교체 알고리즘에 대해 설명해 주세요.
**A**: 페이지 교체 알고리즘은 물리 메모리가 부족할 때 어떤 페이지를 디스크로 스왑아웃할지 결정하는 알고리즘입니다. 주요 목적은 페이지 폴트를 최소화하여 시스템 성능을 최적화하는 것입니다. 대표적인 알고리즘으로는 FIFO, LRU, 최적 알고리즘, Clock 알고리즘 등이 있습니다.

### Q2: LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?
**A**: LRU 알고리즘은 **시간적 지역성(Temporal Locality)** 특성을 이용한 알고리즘입니다. 최근에 참조된 페이지가 다시 참조될 가능성이 높다는 원리를 바탕으로, 가장 오랫동안 사용되지 않은 페이지를 교체 대상으로 선택합니다.

### Q3: LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?
**A**: LRU는 세 가지 방식으로 구현할 수 있습니다. 
1) **카운터 방식**: 각 페이지마다 타임스탬프를 유지하여 가장 오래된 것을 선택
2) **스택 방식**: 더블 링크드 리스트를 이용해 참조된 페이지를 맨 위로 이동
3) **하드웨어 지원 방식**: 참조 비트와 참조 시간 레지스터를 활용한 구현

### Q4: LRU 알고리즘의 단점을 설명해 주세요. 이를 해결할 수 있는 대안에 대해서도 설명해 주세요.
**A**: LRU의 주요 단점은 높은 오버헤드(매 참조마다 순서 정보 업데이트), 하드웨어 지원 필요, 스캔 저항성 부족입니다. 대안으로는 Clock 알고리즘(참조 비트만 사용하여 오버헤드 감소), Working Set 알고리즘(지역성을 더 정확히 반영), WSClock 알고리즘(Working Set과 Clock의 결합) 등이 있습니다.

### Q5: Thrashing이란 무엇인가요?
**A**: 스래싱은 시스템이 실제 유용한 작업보다 페이지 스와핑에 더 많은 시간을 소비하는 현상입니다. 다중프로그래밍 정도가 증가하여 각 프로세스의 할당 프레임이 Working Set보다 작아지면, 빈번한 페이지 폴트가 발생하여 CPU 이용률이 급격히 감소합니다.

### Q6: Thrashing 발생 시, 어떻게 완화할 수 있을까요?
**A**: 스래싱 완화 방법은 다음과 같습니다.
1) **Working Set 모델**: 각 프로세스의 Working Set 크기를 모니터링하여 적절한 메모리 할당
2) **PFF 모델**: 페이지 폴트 빈도에 따른 동적 프레임 할당
3) **다중프로그래밍 정도 제어**: 시스템 부하 모니터링하여 프로세스 수 조정
4) **메모리 할당 정책 개선**: 지역, 비례, 우선순위 기반 할당 정책 적용