---
layout: post
title: "파이프 통신과 파일 디스크립터 리다이렉션 완전 분석"
date: 2020-06-18 10:00:00 +0900
categories: [시스템 프로그래밍]
tags: [pipe, IPC, file descriptor, dup2, process communication, Linux]
---

# 파이프 통신과 파일 디스크립터 리다이렉션 완전 분석

## 개요
Unix/Linux 시스템에서 프로세스 간 통신의 핵심인 파이프(pipe)와 파일 디스크립터 리다이렉션에 대해 깊이 있게 분석해보겠습니다. 특히 `dup2()` 함수가 어떻게 표준 출력을 파이프로 연결하는지 상세히 살펴보겠습니다.

## 분석 대상 코드

```c
#include<stdio.h>
#include<unistd.h>
#include<sys/wait.h>

int main(int argc, char **argv){
    pid_t pid;
    int pfd[2];
    char line[BUFSIZ];
    int status;

    if(pipe(pfd) <0){
        perror("pipe()");
        return -1;
    }

    if((pid = fork())<0){
        perror("fork()");
        return -1;
    }else if(pid ==0){
        close(pfd[0]);
        dup2(pfd[1], 1); // 쓰기를 위한 파일 디스크립터를 표준 출력(1)으로 변경
        execl("/bin/date", "date", 0);
        close(pfd[1]);
        _exit(127);
    }else{
        close(pfd[1]); // 쓰기를 위한 파일 디스크립터 닫기
        if(read(pfd[0], line, BUFSIZ) <0){ // 파일 디스크립터로부터 데이터 읽기
            perror("");
            return -1;
        }
        printf("%s", line);
        close(pfd[0]);
        waitpid(pid, &status, 0);
    }
    return 0;
}
```

## 파이프의 내부 구조와 동작 원리

### 1. 파이프 생성과 커널 버퍼

**파이프의 실체**: `pipe()` 시스템 콜이 호출되면 커널 공간에 파이프 버퍼(일반적으로 64KB)가 생성됩니다.

```c
int pfd[2];
pipe(pfd);  // pfd[0]=읽기용 fd, pfd[1]=쓰기용 fd
```

중요한 것은 `pfd` 배열 자체가 파이프가 아니라는 점입니다. `pfd`는 파이프 자체가 아니라 **파이프에 접근하기 위한 문(door) 역할**을 하며, 단순히 커널의 파이프 버퍼에 접근하기 위한 **파일 디스크립터 번호**를 저장하는 배열입니다.

```
사용자 공간:          커널 공간:
┌─────────────┐      ┌──────────────────┐
│ pfd[0] = 3  │ ──→  │ 파일 디스크립터   │ ──→ ┌─────────────┐
│ pfd[1] = 4  │ ──→  │ 테이블 (FDT)     │     │ 실제 파이프  │
└─────────────┘      └──────────────────┘     │ 버퍼 (64KB) │
   (단순한 숫자)         (커널이 관리)          └─────────────┘
                                              (실제 데이터 저장)
```

### 2. 데이터 흐름 분석

1. **자식 프로세스**: `dup2(pfd[1], 1)` → 표준출력을 파이프 쓰기단으로 리다이렉션
2. **execl("/bin/date", ...)** → date 명령어 출력이 파이프로 전송
3. **출력 데이터**: 커널의 파이프 버퍼에 저장
4. **부모 프로세스**: `read(pfd[0], line, BUFSIZ)` → 커널 버퍼에서 `line` 배열로 데이터 복사

## 파일 디스크립터와 dup2의 핵심 개념

### 표준 출력 리다이렉션의 의미

Unix/Linux에서 모든 것은 파일이라는 철학에 기반하여, 표준입출력도 파일 디스크립터로 관리됩니다:
- 표준입력(0), 표준출력(1), 표준에러(2)

`ls`, `date` 등의 프로그램은 하드코딩된 출력 경로가 없습니다. 단순히 `write(1, data, size)` 형태로 파일 디스크립터 1에 출력할 뿐입니다. **파일 디스크립터 1이 어디를 가리키는지에 따라 출력 위치가 결정**됩니다.

### dup2 함수의 동작 원리

```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

`dup2(pfd[1], 1)`의 정확한 동작:

**호출 전 파일 디스크립터 테이블:**
```
fd[0] → stdin
fd[1] → stdout (터미널)
fd[2] → stderr
fd[3] → 파이프 읽기단 (pfd[0])
fd[4] → 파이프 쓰기단 (pfd[1])
```

**호출 후 파일 디스크립터 테이블:**
```
fd[0] → stdin
fd[1] → 파이프 쓰기단  ← 변경됨! (원래 stdout은 자동으로 닫힘)
fd[2] → stderr
fd[3] → 파이프 읽기단 (pfd[0])
fd[4] → 파이프 쓰기단 (pfd[1])
```

### 시각적 흐름도

```
dup2 호출 전:
┌─────────────┐    fd=1    ┌──────────┐
│   printf()  │ ─────────→ │ 터미널   │
└─────────────┘            └──────────┘

dup2(pfd[1], 1) 호출 후:
┌─────────────┐    fd=1    ┌────────────┐    ┌──────────────┐
│   printf()  │ ─────────→ │ 파이프버퍼  │ ──→│ 부모프로세스 │
└─────────────┘            └────────────┘    └──────────────┘
```

이제 `printf()`나 모든 표준출력이 터미널이 아닌 파이프 버퍼로 전송됩니다.

## 부모 프로세스에서 쓰기 파일 디스크립터를 닫는 이유

파이프의 EOF 처리 메커니즘 때문입니다:
- 모든 쓰기 파일 디스크립터가 닫혀야 읽기측에서 EOF를 감지
- 부모가 `pfd[1]`을 닫지 않으면 `read()`가 무한 대기할 수 있음

```c
// 올바른 파이프 사용 패턴
parent: close(pfd[1]) → 쓰기단 완전 차단
child:  close(pfd[0]) → 읽기단 불필요하므로 차단
```

### 우체통 비유로 이해하기

```
실제 파이프 버퍼 = 우체통 (데이터가 실제로 저장되는 곳)
pfd[1] = 우체통 투입구 열쇠 번호 (쓰기용)
pfd[0] = 우체통 수취구 열쇠 번호 (읽기용)

┌─────────────┐                ┌─────────────┐
│자식프로세스  │   pfd[1]열쇠    │             │   pfd[0]열쇠   ┌─────────────┐
│   (date)    │ ──────────────→ │ 커널우체통   │ ──────────────→│부모프로세스  │
└─────────────┘      편지넣기    │  (파이프)   │      편지꺼내기  └─────────────┘
                                └─────────────┘
```

## 파이프 통신의 특성

### 1. 프로세스 간 데이터 격리
파이프는 **단방향 통신**이며, 파일 디스크립터를 공유하지 않는 프로세스는 접근이 불가능합니다. 파이프 데이터는 **한 번 읽으면 소비**되는 FIFO 구조입니다.

### 2. 커널 관리 버퍼
사용자가 별도로 버퍼를 설정하지 않는 이유는 커널이 자동으로 파이프 버퍼를 관리하기 때문입니다. `read()` 시스템 콜이 커널의 파이프 버퍼에서 사용자 공간의 배열로 데이터를 복사합니다.

## popen/pclose - 고수준 파이프 함수

`popen`은 **파이프 + fork + exec**을 하나로 합친 고수준 함수입니다:

```c
#include <stdio.h>
FILE *popen(const char *command, const char *mode);
int pclose(FILE *stream);
```

### 코드 비교

**기존 방식 (pipe + fork + exec):**
```c
int pfd[2];
pipe(pfd);
if (fork() == 0) {
    close(pfd[0]);
    dup2(pfd[1], 1);
    execl("/bin/date", "date", NULL);
} else {
    close(pfd[1]);
    read(pfd[0], buffer, sizeof(buffer));
    close(pfd[0]);
}
```

**popen 사용:**
```c
FILE *fp = popen("date", "r");
fgets(buffer, sizeof(buffer), fp);
pclose(fp);
```

### 선택 기준
- **popen 사용**: 단순한 명령어 실행 및 결과 읽기
- **직접 pipe 사용**: 양방향 통신, 세밀한 파일 디스크립터 제어, 다중 파이프 연결

## 실습 예제

### 파일 디스크립터 변화 확인
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    int pfd[2];
    pipe(pfd);
    
    printf("dup2 호출 전: 터미널에 출력\n");
    
    dup2(pfd[1], 1);  // 표준출력을 파이프로 리다이렉션
    
    printf("dup2 호출 후: 이 메시지는 터미널에 안 보임!\n");
    // 이 printf 출력은 파이프 버퍼로 들어감
    
    return 0;
}
```

## 결론

파이프 통신은 Unix/Linux 시스템의 핵심 IPC 메커니즘으로, 파일 디스크립터 리다이렉션을 통해 프로그램 수정 없이도 데이터 흐름을 제어할 수 있습니다. `dup2()` 함수는 파일 디스크립터 테이블을 조작하여 표준 입출력의 대상을 변경하는 강력한 도구입니다.

중요한 점은 파이프 자체는 커널이 관리하는 버퍼이며, 사용자 공간의 파일 디스크립터는 단순히 이 버퍼에 접근하기 위한 "열쇠"역할을 한다는 것입니다. 이러한 추상화를 통해 Unix/Linux는 강력하고 유연한 프로세스 간 통신을 제공합니다.

---

**카테고리**: 시스템 프로그래밍  
**태그**: pipe, IPC, file descriptor, dup2, process communication, Linux