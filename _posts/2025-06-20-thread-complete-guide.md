---
layout: post
title: "스레드의 모든 것: 하드웨어부터 소프트웨어까지"
date: 2025-06-20 23:00:00 +0900
categories: [OS]
tags: [thread, operating-system, hardware, software, scheduling, concurrency, parallelism]
---

# 스레드의 모든 것: 하드웨어부터 소프트웨어까지

컴퓨터에서 "스레드"라는 용어를 들어보셨나요? CPU 스펙에서 "4코어 8스레드", 프로그래밍에서 "멀티스레딩", 운영체제에서 "커널 스레드" 등... 같은 단어지만 전혀 다른 의미를 가지고 있습니다. 오늘은 이 모든 스레드들이 어떻게 연결되어 동작하는지 알아보겠습니다.

## 스레드의 3가지 레벨

### 1. 하드웨어 스레드 (Hardware Thread)

**"잠깐, CPU의 4코어 8threads 할 때 그 스레드도 같은 건가요?"**

아니요! 이건 완전히 다른 개념입니다. CPU 스펙에서 말하는 "4코어 8스레드"의 그 스레드가 바로 **하드웨어 스레드**입니다.

**특징:**
- 하이퍼스레딩 기술로 구현
- 하나의 물리 코어가 두 개의 명령어 스트림을 동시 처리
- 4코어 × 2 하이퍼스레딩 = 8개 하드웨어 스레드
- 운영체제는 이를 8개의 CPU로 인식

**하드웨어 스레드의 역할:**
하드웨어 스레드는 **실제 명령어 실행의 최종 단계**입니다. CPU 내부에서 다음과 같은 역할을 담당합니다:

- **명령어 파이프라인 관리**: 각 하드웨어 스레드마다 독립적인 명령어 파이프라인 유지
- **레지스터 세트 분리**: 각 스레드가 고유한 레지스터 세트를 가져 컨텍스트 분리
- **실행 유닛 공유**: ALU, FPU 등의 실행 유닛을 여러 하드웨어 스레드가 공유하여 효율성 극대화
- **캐시 활용 최적화**: 한 스레드가 메모리 대기 중일 때 다른 스레드가 CPU 사용하여 유휴 시간 최소화

예를 들어, 8개 하드웨어 스레드 시스템에서는 **동시에 최대 8개의 명령어**만 실제로 실행될 수 있습니다. 이것이 바로 **물리적 병렬 처리의 한계**가 되는 지점입니다.

### 2. 커널 레벨 스레드 (OS Thread)
운영체제가 직접 관리하는 스레드입니다. 흔히 "OS 스레드"라고도 부릅니다.

**특징:**
- 커널이 직접 생성, 삭제, 스케줄링 담당
- 각 스레드마다 고유한 ID 할당
- 시스템 콜을 통해 생성 (pthread_create, CreateThread 등)
- 한 스레드가 블로킹되어도 다른 스레드는 계속 실행
- 멀티코어에서 진정한 병렬 처리 가능

**단점:**
- 생성/삭제 비용이 높음
- 컨텍스트 스위칭 오버헤드 존재

### 3. 유저 레벨 스레드 (User-level Thread)
애플리케이션 라이브러리가 관리하는 가벼운 스레드입니다.

**특징:**
- 사용자 공간의 라이브러리가 관리
- 커널은 스레드의 존재를 모름 (단일 프로세스로 인식)
- 매우 빠른 생성/삭제 및 컨텍스트 스위칭
- Go의 고루틴, 초기 Java의 Green Thread가 대표적

**단점:**
- 한 스레드가 블로킹되면 전체 프로세스가 블로킹
- 진정한 병렬 처리 불가능

**"그러면 이게 HAL(Hardware Abstraction Layer)과 비슷한 느낌인가요?"**

정확합니다! 유저 레벨 스레드는 HAL과 매우 유사한 역할을 합니다. 커널 스레드라는 "무거운 하드웨어" 위에 "가벼운 추상화 계층"을 제공하여, 애플리케이션이 커널의 복잡성을 신경 쓰지 않고도 스레드를 사용할 수 있게 해줍니다.

## 스레드 매핑 모델

유저 레벨 스레드와 커널 레벨 스레드는 다음과 같은 방식으로 매핑됩니다:

### Many-to-One 모델
```
[User Thread 1]
[User Thread 2]  →  [Kernel Thread 1]
[User Thread 3]
```
여러 유저 스레드가 하나의 커널 스레드에 매핑. 초기 Java Green Thread 방식.

### One-to-One 모델
```
[User Thread 1]  →  [Kernel Thread 1]
[User Thread 2]  →  [Kernel Thread 2]
[User Thread 3]  →  [Kernel Thread 3]
```
유저 스레드마다 커널 스레드를 1:1 매핑. 현재 Java, pthread의 기본 방식.

### Many-to-Many 모델 (하이브리드)
```
[User Thread 1]     [Kernel Thread 1]
[User Thread 2]  ↗  [Kernel Thread 2]
[User Thread 3]  ↘  [Kernel Thread 3]
[User Thread 4]
```
적은 수의 커널 스레드에 많은 유저 스레드를 동적 매핑. Go의 고루틴이 대표적.

**"그런데 유저 레벨과 커널 레벨이 어떻게 연결되는 거죠?"**

이것이 바로 핵심입니다! 위의 3가지 매핑 모델이 그 연결 방식을 보여줍니다. 런타임 라이브러리나 가상머신이 이 매핑을 관리하며, 개발자는 유저 스레드만 만들면 시스템이 알아서 커널 스레드와 연결해줍니다.

## 전체 시스템의 스레드 경쟁

**"그런데 커널 스레드와 하드웨어 스레드도 매핑이 되어야 하는 거 아닌가요?"**

맞습니다! 완전한 그림을 보려면 **3단계 매핑**이 모두 필요합니다:

```
[User Threads]           (애플리케이션 레벨)
      ↓ (1단계 매핑)
[Kernel Threads/OS Threads]  (운영체제 레벨)
      ↓ (2단계 매핑) 
[Hardware Threads]       (CPU 레벨)
```

**"그러면 1000개가 100개와 경쟁하고, 100개가 8개와 경쟁하는 건가요?"**

정확히 맞습니다! 각 레벨에서 **스케줄링 경쟁**이 일어납니다.

### 1단계: User Thread → Kernel Thread
```
애플리케이션 A: 1000개 유저 스레드 → 100개 커널 스레드
애플리케이션 B: 500개 유저 스레드 → 50개 커널 스레드
```
**스케줄러:** 런타임 라이브러리 (Go runtime, JVM 등)

### 2단계: 전체 시스템의 Kernel Thread 경쟁
```
Chrome: 200개 커널 스레드
VSCode: 150개 커널 스레드
게임: 50개 커널 스레드         } → 총 수천 개 커널 스레드
시스템 프로세스: 300개 커널 스레드
기타 백그라운드 앱들...
```
**스케줄러:** 운영체제 커널 스케줄러

### 3단계: Kernel Thread → Hardware Thread
```
전체 시스템: 3000개 커널 스레드 → 8개 하드웨어 스레드
```
**스케줄러:** CPU 스케줄러

**"그런데 프로그램을 여러 개 돌리면 상황이 더 복잡해지겠네요?"**

맞습니다! 실제 시스템에서는 **전체 시스템 레벨**에서 훨씬 더 복잡한 경쟁이 일어납니다.

## 동시성 vs 병렬성

이 모든 구조를 통해 우리는 **동시성**과 **병렬성**의 차이를 이해할 수 있습니다:

**동시성 (Concurrency):**
- 논리적으로 여러 작업이 동시에 진행되는 것처럼 보임
- 수천 개의 스레드가 "동시에" 실행되는 것처럼 느껴짐

**병렬성 (Parallelism):**
- 물리적으로 실제 동시 실행
- 8개 하드웨어 스레드 시스템에서는 최대 8개만 진짜 동시 실행

## 실제 동작 예시

**8코어 16스레드 시스템에서:**

1. **유저가 여러 프로그램 실행**
   - Chrome (200개 커널 스레드)
   - VSCode (150개 커널 스레드)
   - 게임 (50개 커널 스레드)
   - 시스템 프로세스들 (300개 커널 스레드)

2. **OS 스케줄러가 관리**
   - 총 700개 커널 스레드를 16개 하드웨어 스레드에 배분
   - 시분할 방식으로 몇 ms씩 번갈아가며 실행
   - 우선순위에 따라 CPU 시간 차등 배분

**"OS 스레드는 뭔가요? 커널 레벨 스레드와 같은 건가요?"**

네, 맞습니다! "OS 스레드"는 **커널 레벨 스레드**와 같은 의미입니다. 운영체제가 직접 생성하고 관리하는 스레드로, 시스템 콜을 통해 생성되는 "진짜" 스레드를 말합니다. 유저 레벨 스레드와 대비되는 개념이죠.

3. **사용자 경험**
   - 모든 프로그램이 동시에 실행되는 것처럼 느껴짐
   - 실제로는 16개만 동시 실행, 나머지는 빠른 전환으로 착각 유발

## 정리

현대 컴퓨터의 스레드 시스템은 하드웨어부터 소프트웨어까지 여러 계층의 추상화와 스케줄링이 복합적으로 작동하는 정교한 시스템입니다. 

**HAL(Hardware Abstraction Layer)**과 유사하게, 각 레벨의 스레드는 하위 레벨의 복잡성을 숨기고 상위 레벨에 편리한 인터페이스를 제공합니다. 개발자는 이런 복잡한 매핑과 스케줄링을 신경 쓰지 않고도 수천 개의 스레드를 만들어 사용할 수 있습니다.

## 레이어별 스케줄링 방법론의 차이

**"그런데 스케줄링 방법론은 각 레이어마다 똑같이 적용되나요?"**

아니요! 각 레이어의 스케줄링 방법론은 **목적과 제약사항이 다르기 때문에** 서로 다른 방식을 사용합니다.

### 유저 레벨 스레드 스케줄링
**목적:** 가벼움과 빠른 전환  
**주요 방법론:**
- **협력적 스케줄링(Cooperative)**: 스레드가 자발적으로 양보
- **간단한 라운드로빈**: 복잡한 우선순위 없이 순서대로
- **이벤트 기반**: I/O 이벤트에 반응하여 스케줄링

**특징:**
- 커널 개입 없음 → 매우 빠름 (마이크로초 단위)
- 선점형 스케줄링 어려움 (커널 타이머 없음)
- 애플리케이션 특성에 맞춘 커스텀 스케줄링 가능

**예시:** Go의 work-stealing 알고리즘
```
- 각 OS 스레드가 고루틴 큐를 가짐
- 일이 없으면 다른 스레드에서 고루틴을 "훔쳐옴"
- 매우 빠른 전환으로 높은 처리량 달성
```

### 커널 레벨 스레드 스케줄링
**목적:** 공정성과 시스템 안정성  
**주요 방법론:**
- **선점형 스케줄링(Preemptive)**: 강제로 CPU 회수
- **CFS (Completely Fair Scheduler)**: Linux의 공정한 스케줄링
- **우선순위 기반**: 시스템 > 사용자 > 백그라운드
- **시분할**: 타임 슬라이스 기반 강제 전환

**특징:**
- 타이머 인터럽트 활용 (밀리초 단위)
- 복잡한 우선순위 계산
- 전체 시스템 관점에서 최적화

**예시:** Linux CFS
```
- 각 스레드의 가상 런타임 추적
- 가장 적게 실행된 스레드 우선 선택
- 레드-블랙 트리로 효율적 관리
```

### 하드웨어 스레드 "스케줄링"
**목적:** 하드웨어 자원 효율성  
**주요 방법론:**
- **즉시 실행**: 사용 가능한 하드웨어 스레드에 바로 할당
- **하드웨어 기반 선택**: CPU 내부 로직으로 결정
- **파이프라인 최적화**: 캐시 미스, 분기 예측 실패 시 다른 스레드로 전환

**특징:**
- 나노초 단위 전환
- 하드웨어가 자동으로 최적 선택
- 파이프라인 효율성 극대화

**예시:** Intel SMT (Simultaneous Multithreading)
```
- 파이프라인 슬롯이 비면 즉시 다른 스레드 명령어 삽입
- 하드웨어가 실시간으로 최적화
- 캐시 미스 대기 시간을 다른 스레드 실행으로 활용
```

### 레이어별 스케줄링 비교

| 레이어 | 전환 속도 | 스케줄링 단위 | 주요 목표 | 대표적 방법 |
|--------|-----------|---------------|-----------|-------------|
| 유저 레벨 | 마이크로초 | 협력적/이벤트 | 애플리케이션 성능 | Work-stealing |
| 커널 레벨 | 밀리초 | 선점형/우선순위 | 시스템 공정성 | CFS, 우선순위 스케줄링 |
| 하드웨어 | 나노초 | 즉시/자동 | 하드웨어 효율성 | SMT, 파이프라인 최적화 |

**핵심 인사이트:**  
각 레이어는 서로 다른 **시간 스케일**과 **목적**을 가지고 있어서, 동일한 스케줄링 방법론을 사용하지 않습니다. 오히려 각 레이어의 특성에 최적화된 방법을 사용해야 전체 시스템이 효율적으로 동작할 수 있습니다!
